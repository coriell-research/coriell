---
title: "RNA-seq-workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RNA-seq-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

Below, I will illustrate some of the functions present in the `coriell`
package by walking through a typical RNA-seq workflow, starting with count files
generated using the STAR aligner and progressing through differential
expression analysis. 

## Load in the data generated by STAR

The example data were generated by aligning reads from the [Targeting CDK9 Reactivates Epigenetically Silenced Genes in Cancer](https://pubmed.ncbi.nlm.nih.gov/30454645/) paper by Dr. Issa's lab to the
hg38 genome using STAR. For brevity, only the day 4 DMSO and HH1 10uM samples
have been included. The complete raw data can be found on [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE104837).

The output from STAR is a tab delimited file with columns containing the gene name,
unstranded count, forward stranded count, and reverse stranded count. 

```{r}
dir <- system.file("extdata", package = "coriell")
files <- list.files(dir, full.names = TRUE, pattern = "*.ReadsPerGene.out.tab")

files
```

Read the files into a single dataframe with `vroom`. Since the sequencing prep was
an Illumina Truseq kit we want to select the unstranded counts for our analysis.

```{r}
count_df <- vroom::vroom(files,
  id = "fpath",
  delim = "\t",
  col_names = c("gene", "unstranded", "forward", "reverse")
)

head(count_df)
```

We can now clean up the dataframe by extracting the sample names from the fpath 
column, removing the gene rows that begin with "N_", and selecting the unstranded
counts. To make the resulting dataset a little smaller we can also filter out
rows with zero counts. 

*Note the use of the `%<>%` pipe below which reassigns the results of filtering to the `count_df` variable*

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(tools)


count_df %<>%
  mutate(
    sample_name = file_path_sans_ext(basename(fpath)),
    sample_name = str_remove(sample_name, "_S[0-9].ReadsPerGene.out")
  ) %>%
  filter(!str_detect(gene, "^N_")) %>%
  select(gene, sample_name, unstranded) %>%
  filter(unstranded > 0)

head(count_df)
```

## Coerce the data frame into a count matrix

All software dealing with RNA-seq data expects the data to be in the shape where
columns represent samples and rows represent genes. To acheive this we will pivot 
the count_df wider into a count matrix. Additionally, we will turn the gene column
into rownames.

```{r}
count_mat <- count_df %>%
  pivot_wider(
    names_from = sample_name,
    values_from = unstranded,
    values_fill = 0
  ) %>%
  column_to_rownames(var = "gene")

head(count_mat)
```

## Create sample annotation information

We can either read in metadata about our samples from a file that we created 
externally or we can create sample metadata from the sample names themselves. 
Below, we will create sample metadata from the colnames of the count_mat. 

Since there is only one time point present we will ignore extracting the time
from the sample name and simply compare the two treatment groups.

```{r}
sample_df <- colnames(count_mat) %>%
  enframe(name = NULL, value = "sample_name") %>%
  mutate(
    group = if_else(str_detect(sample_name, "DMSO"), "DMSO", "HH1_10uM"),
    group = factor(group, levels = c("DMSO", "HH1_10uM"))
  ) %>%
  column_to_rownames(var = "sample_name")

# it is important that the colnames of the count_mat match the rownames of samples_df
all(colnames(count_mat) == rownames(sample_df))

head(sample_df)
```

## Read in information about genes

This step is not strictly necessary but it can be useful to read in information
about the genes. For example, since the genes in the count matrix have Ensembl
IDs we might want to know their gene symbol or we might want to calculate RPKMs
in which case we would need information about gene lengths. 

These samples were aligned to the Ensembl hg38.100 build using the matching GTF
file. Therefore, we can use this GTF file to annotate our genes. We will use 
`rtracklayer` to import the GTF file we download from the Ensembl FTP server. 
`rtracklayer` imports the file as a `GRanges` object so we will coerce it to a 
dataframe so we can filter.

```{r message=FALSE, warning=FALSE}
# get the GTF file from Ensembl
url <- "ftp://ftp.ensembl.org/pub/release-100/gtf/homo_sapiens/Homo_sapiens.GRCh38.100.gtf.gz"
gtf_file <- "~/Downloads/Homo_sapiens.GRCh38.100.gtf.gz"

# if the file isn't in the Downloads folder, download it
if (!file.exists(gtf_file)) download.file(url, gtf_file)

# load the gtf file as a dataframe
gtf_df <- as.data.frame(rtracklayer::import(gtf_file))

head(gtf_df)
```

Next, we will filter the gtf_df to include only the Ensembl IDs present in our
count_mat. We can left_join the GTF information from genes onto our gene_ids and
then select only relevant columns. 

```{r}
gene_df <- rownames(count_mat) %>%
  enframe(name = NULL, value = "gene_id") %>%
  left_join(y = {
    gtf_df %>% filter(type == "gene")
  }, by = "gene_id") %>%
  select(gene_id,
    chr = seqnames,
    start,
    end,
    length = width,
    strand,
    gene_name,
    gene_biotype
  ) %>% 
  column_to_rownames(var = "gene_id")

# check to see if rownames of gene_df match those of count_mat
all(rownames(count_mat) == rownames(gene_df))

head(gene_df)
```

## Load data into edgeR

We can now load our data into `edgeR` and start our analysis. **NOTE** the naming
of some of the variable names above was deliberate. `edgeR` expects groups to be 
named 'group' as a column in your sample annotation, otherwise you must specify
group names in `edgeR` functions. Likewise, in the gene annotation `edgeR` looks
for a column named 'length' to calculate RPKMs. You don't have to name your 
columns with these conventions however it makes working with `edgeR` a little 
easier.

```{r}
library(edgeR)

# load data into an edger object
y <- DGEList(counts = count_mat,
             samples = sample_df,
             genes = gene_df)
```

## Specify study design

Since we're only comparing two groups the design is straightforward. We can 
specify the design matrix by either setting an intercept to be the first factor
level `design <- model.matrix(~sample_df$group)` or by setting each group as a 
column in the resulting design matrix and using contrasts to make comparisons. I
am a fan of setting up contrasts because they are generally easier to understand
and are easier to expand upon if the experimental design gets more complicated.

```{r}
design <- model.matrix(~0 + sample_df$group)
rownames(design) <- rownames(sample_df)
colnames(design) <- levels(sample_df$group)

design
```

## Filter genes by their expression

Since a gene has to be transcribed a certain number of times to really be 
expressed we want to filter out genes that are lowly expressed. `edgeR` 
accomplishes this with the `filterByExpr` function.

```{r}
keep <- filterByExpr(y, design = design)
y <- y[keep, ]

table(keep)
```

## Calculate normalization factors

`edgeR` uses TMM to calculate normalization factors. These norm factors are then
used in downstream analysis to normalize the gene counts within and between samples.

```{r}
y <- calcNormFactors(y, method = "TMM")
```

We can check the normalization by creating an MD plot for each sample vs the 
expression levels in all other samples. `edgeR` has a function `plotMD` for this
purpose. We can wrap this function in another caller and map it across all of 
our samples to easily check the entire dataset.

The bulk of the data should be zero-centered and generally horizontal across. 
Since this is only a subset of the entire dataset it is not surprising that there
is some skew in the normalization. 

```{r}
plot_meanDifference <- function(col) {
  plotMD(cpm(y, log = TRUE), column = col)
  abline(h = 0, col = "red", lty = 2, lwd = 2)
}
# apply plot func to all columns
walk(1:ncol(y$counts), plot_meanDifference)
```

## Estimate dispersion

Next we estimate the dispersion. The dispersion values are critical for estimating
DE. You need at least two replicates in a single group to calculate dispersions. 
Of course, however, more groups and more replicates (at least triplicates) will 
improve the analysis.

```{r}
y <- estimateDisp(y, design, robust = TRUE)
```

### Plot BCV

We can plot the dispersion estimates below. `edgeR` calculates dispersion in 
three ways which may or may not be used depending on the DE test you choose. The 
tagwise dispersion is the dispersion for any individual gene. The trended dispersion
is a smoothed dispersion estimate for genes of a given expression level and the
common dispersion is essentially an estimate of the mean dispersion of all genes. 

It is typical to see dispersions higher and more variable for lower expressed 
genes and then asymptotically get closer to zero as expression increases.

```{r}
plotBCV(y)
```

## Fit QL model

Depending on the test to be used you will typically need to fit a model to the data.
`edgeR` does this with the `glmQLFit` framework. Running this function fits a model
to the expression data that can then be used downstream in DE testing.

```{r}
fit <- glmQLFit(y, design, robust = TRUE)
```

### Plot QL dispersions

The `glmQLFit` function is similar to `glmFit` but uses `squeezeVar` from `limma`
to conduct empirical Bayes moderation of the genewise QL dispersions. These 
squeezed estimates help to provide better estimates in the final DE test. We can 
view the fitted estimates with the `plotQLDisp` function.

```{r}
plotQLDisp(fit)
```

## Specify contrasts for DE testing

We can now use the design matrix to select the columns we want to compare. Below
we are looking for the differential gene expression in HH1_10uM vs DMSO. Positive 
logFCs in the results indicate that a gene is up-regulated in HH1_10uM whereas
negative values for the logFC indicate the gene was down-regulated in HH1_10uM.

```{r}
con <- makeContrasts(hh1_vs_dmso = HH1_10uM - DMSO, levels = design)
```

## Perform DE testing

Below, we will use the `glmTreat` function to test for DE relative to a logFC 
cutoff. Moderate values for the `lfc` parameter in the `glmTreat` function typically 
reflect testing for a roughly 2 fold-change. This method is better than performing
a LRT or `exactTest` and then filtering for FDR and logFCs.

This is also the moment where the `coriell` functions become helpful. We will 
now attach the `coriell` package and start using some of the functions.

```{r}
library(coriell)


res <- glmTreat(fit, contrast = con[, "hh1_vs_dmso"], lfc = log2(1.2))

# convert the edger result to a dataframe
res_df <- edger_to_df(res)

head(res_df)
```

## Create plots from DE testing

We can now use some of the `coriell` functions to create plots. For example, 
we can use the `plot_volcano` function to create a volcano plot of the results. 
The `plot_volcano` function automatically summarizes and annotates the plot with
the counts of the up and down regulated genes. The `plot_volcano` and the `plot_md`
functions both return `ggplot` objects so you can always modify them, for example
to add a title.

The plotting functions also have options to adjust the positioning of the labels 
or remove them entirely. The plot functions can also be used the label the genes
using `ggrepel`. Use `?plot_volcano` and `?plot_md` to see all of the functionality.

```{r}
# summarize the results into a nice table
summarize_dge(res_df, fdr = 0.1, lfc = log2(1.2))

# create a volcano plot
plot_volcano(res_df, fdr = 0.1, lfc = log2(1.2)) +
  ggtitle("HH1 vs DMSO at 4 Days")

# create an md plot
plot_md(res_df, fdr = 0.1, lfc = log2(1.2)) +
  ggtitle("HH1 vs DMSO at 4 Days")
```

## Create a heatmap from the data

Another useful way of looking at expression data is to compare gene expression
on a heatmap. The `coriell::quickmap` function provides a wrapper around `pheatmap`
with some defaults that are useful for RNA-seq data. Any parameter that `pheatmap`
accepts can be passed into the `quickmap` function as well.

```{r}
# calculate the logCPMs with edger
lcpms <- cpm(y, log = TRUE, prior.count = 5)

# plot the heatmap with quickmap
quickmap(lcpms, main = "All Genes")

# plotting only significant genes
sig_genes <- res_df %>% 
  filter(FDR < 0.1) %>% 
  pull(feature_id)

# subset the lcpms matrix to include only genes found to be DE
sig_lcpms <- subset(lcpms, rownames(lcpms) %in% sig_genes)

quickmap(sig_lcpms, main = "Significant Genes")
```

## Perform Gene Ontology search on DE genes

Another common task is to perform gene ontology on the differentially expressed
genes. `coriell::panther_go` provides a function that takes in a list of gene ids
and submits a request to the PANTHER db for GO analysis. It then returns the 
parsed json results as a tibble. 

The `panther_go` function accepts any gene id that PANTHER accepts. The only 
arguments that must be provided are the list of genes, the taxon id, and the
GO terms you want to search for. For a complete listing of the options see
`?coriell::panther_go`

```{r}
# extract the top 100 up-regulated ensembl ids
up_ids <- res_df %>% 
  filter(FDR < 0.1 & logFC > 0) %>% 
  slice_max(n = 100, order_by = abs(logFC)) %>% 
  pull(feature_id)

# extract the top 100 down-regulated ensembl gene ids
down_ids <- res_df %>% 
  filter(FDR < 0.1 & logFC < 0) %>% 
  slice_max(n = 100, order_by = abs(logFC)) %>% 
  pull(feature_id)

# perform GO analysis with PANTHER on up-genes
panther_up <- panther_go(up_ids, "9606", "biological_process")

# perform GO analysis with PANTHER on down-genes
panther_down <- panther_go(down_ids, "9606", "biological_process")

head(panther_up$table)
head(panther_down$table)
```

The function can also work with the gene names.

```{r}
up_genes <- res_df %>% 
  filter(FDR < 0.1 & logFC > 0) %>% 
  slice_max(n = 100, order_by = abs(logFC)) %>%
  distinct(gene_name) %>% 
  pull(gene_name)
  
panther_up2 <- panther_go(up_genes, "9606", "biological_process")
head(panther_up2$table)
```
